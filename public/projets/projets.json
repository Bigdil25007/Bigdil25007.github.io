[
    {
        "titre": "Conception d’un programme de traitement d’images en ASCII Art",
        "paragraphe1": "Lors d’un projet proposé par mon IUT, j’ai eu l’occasion de créer un programme en C++ qui récupère une image en noir et blanc et la transforme en ASCII Art. Cela signifie que chaque pixel de l’image d’origine est remplacé par un caractère numérique. En jouant avec la disposition et la taille de ces caractères, nous nous retrouvons avec une image semblable à celle d’origine.",
        "image1": "sources/projets/0/resultat.webp",
        "DescriptionIMG1": "Exemple de résultat fourni par le programme",
        "paragraphe2": "Pour arriver au résultat final, j’ai dû passer par plusieurs étapes.\r\nTout d’abord, la récupération des données de l’image originale. C’est-à-dire récupérer la taille de l’image, puis les valeurs de chaque pixel correspondant à des nuances de gris. Pour faire cela, le programme lit ligne par ligne le fichier et enregistre les données nécessaires.\r\nEnsuite, le programme lit un fichier texte qui correspond à la palette de caractères numériques. Puisque la taille de cette palette n’est pas limitée, il a fallu automatiser le programme pour que le résultat soit correct peu importe la taille de la palette.\r\nAprès avoir récupéré toutes les informations essentielles au fonctionnement, le programme peut commencer à créer l’image en ASCII Art. Pour cela le programme étudie chaque valeur de gris de chaque pixel et l’attribue à l’un des caractères de la palette.\r\nFinalement, le programme crée un fichier texte et y stocke le résultat ce qui nous donne une image convertie en ASCII Art. Mais pour que le programme puisse être plus facile d’accès, le programme demande à l’utilisateur directement depuis la console C++ l’image à recréer et la palette à utiliser.",
        "image2": "sources/projets/0/code.webp",
        "DescriptionIMG2": "Extrait de la boucle permettant de remplacer chaque pixel par un caractère ASCII",
        "paragraphe3": "Cette tâche m’a permis de mobiliser plusieurs compétences. En effet faire ce programme nécessitait des connaissances en manipulation de fichiers au travers d’un algorithme puisqu’il fallait savoir récupérer un fichier, lire ses données, et en créer un autre. J’avais déjà pu faire de la manipulation de fichiers auparavant mais jamais avec des fichiers image. Il m’a donc fallu apprendre comment lire spécifiquement ces derniers et comment récupérer les valeurs de chaque pixel pour pouvoir les traiter. De plus j’ai dû faire un compte rendu de mon travail pour expliquer mon approche et mon résultat.\r\nGlobalement, je considère mon programme comme correct et complet. Il pourrait très bien être intégrer dans un autre programme ayant comme tâche secondaire la génération d’un ASCII Art. Cependant je sais qu’il reste encore des éléments à corriger et améliorer. Je pourrais par exemple mieux gérer le cas où le fichier image à traiter n’existe pas, ou bien ajouter la possibilité de réduire la taille de l’image finale.",
        "image3": "sources/projets/0/cmd.webp",
        "DescriptionIMG3": "Affichage console expliquant comment utiliser le programme"
    },
    {
        "titre": "Comparaison d’approches algorithmiques - Sélection du meilleur algorithme de tri",
        "paragraphe1": "En programmation, il est souvent nécessaire de trier une liste ou un tableau. Pour faire cette action, il existe plusieurs algorithmes amenant au même résultat, leur seule différence étant leur temps d’exécution. Mais puisque les tableaux et listes peuvent déjà être plus ou moins triés et leur taille peut être plus ou moins grande, il est important de choisir l’algorithme le plus efficace pour que le programme soit le plus rapide possible.\r\n Lors de ce travail, j’ai donc dû implémenter en C++ plusieurs algorithmes de tri puis regarder leur temps d’exécution en fonction des tableaux fournis dans l’objectif de trouver le meilleur algorithme.",
        "image1": "sources/projets/1/code.webp",
        "DescriptionIMG1": "Déclaration des fonctions de tri",
        "paragraphe2": "Pour faire cela, il a fallu tout d’abord créer des fonctions retournant des tableaux plus ou moins triés (ex : tableau trié au début / tableau trié à la fin / tableau aléatoire). Une fois cette étape terminée, j’ai pu commencer à implémenter en C++ des algorithmes de tri à partir de leur pseudo-code trouvé sur internet. J’ai notamment codé le tri par sélection, le tri bulles, le tri rapide et le tri par insertion. Après avoir vérifié que ces algorithmes fonctionnaient bien, j’ai pu leur rajouter une variable qui a pour rôle de compter le nombre de comparaisons faites lors de l’exécution. Grâce à cette variable, je peux donc voir le nombre de comparaisons faites par chaque algorithme sur différents tableaux.\r\n Après avoir fait cette étape, il ne me restait plus qu’à sauvegarder les valeurs prises par cette variable au cours de l’exécution et de les sauvegarder. Pour cela j’ai indiqué à mon programme qu’il devait stocker les valeurs dans un fichier CSV (tableau Excel où chaque valeur est séparée par une virgule). J’ai donc fait plusieurs boucles pour automatiser le transfert des valeurs du programme au fichier CSV que ce dernier crée.\r\n Pour terminer, j’ai transformé manuellement les valeurs du fichier CSV en courbe pour pouvoir comparer plus facilement les algorithmes. Grâce à ces résultats visuels, j’ai pu faire un compte rendu et une conclusion de mon travail.",
        "image2": "sources/projets/1/courbe.webp",
        "DescriptionIMG2": "On peut voir, par exemple, sur ce graphe que les tri peigne, rapide et à bulles sont les plus rapides",
        "paragraphe3": "Cette étude des algorithmes de tri m’a demandé un certain niveau de maîtrise en programmation et en C++ pour pouvoir implémenter ces algorithmes correctement. J’ai aussi dû comprendre comment fonctionne un fichier CSV pour pouvoir, directement depuis le programme, envoyer les valeurs et les organiser correctement (faire les retours à la ligne et la séparation des valeurs). De plus ce travail m’a permis de m’intéresser à la catégorisation d’algorithmes en fonction de leur complexité temporelle.\r\n Ce travail a été très intéressant à faire. Il a été pour moi une sorte d’introduction à l’optimisation en programmation – chercher à rendre notre programme le plus rapide et le plus efficace. Mais je considère que mon rendu est incomplet. Par manque de temps et d’expérience, je n’ai pas su implémenter certains algorithmes de tri comme le Smoothsort alors même qu’il est considéré comme l’un des plus rapides. De plus, ma conclusion sur le compte rendu manque de contenu et n’apportent pas une étude très approfondi des courbes.",
        "image3": "sources/projets/1/tableau.webp",
        "DescriptionIMG3": "Extrait du fichier CSV ouvert sur Excel. On peut y voir le nombre de comparaison du tri par sélection selon 3 tableaux plus ou moins triés"
    },
    {
        "titre": "Amélioration de l’environnement de développement d’étudiants en informatique - Étude et comparaison d’outils web",
        "paragraphe1": "Lors de ce projet, nous étions par groupe de 5 et devions proposer différents outils pour permettre à des étudiants en informatique d’organiser une game jam. Nous avons donc reçu un cahier des charges nous informant des besoins et exigences du groupe d’étudiants. À partir de ces informations, nous avons entamé des recherches dans l’objectif de trouver un outil d’hébergement web, un système de gestion de base de données (SGBD) et un éditeur de code source. Ces recherches ont ensuite été regroupées sous la forme d’un compte-rendu ainsi qu’un oral de présentation.",
        "image1": "sources/projets/2/solution.webp",
        "DescriptionIMG1": "Une des solutions envisagées",
        "paragraphe2": "Avant d’entamer nos recherches, nous avons dû prendre le temps d’analyser et comprendre le cahier des charges pour pouvoir proposer la meilleure solution.\r\nUne fois cette étape terminée, nous avons pu entamer les recherches. Pour cela nous avons relevé les meilleurs outils, puis nous les avons comparé entre eux. Nous avons ainsi vu par exemple ; Apache, Nginx, Oracle, MySQL, VS Code, etc.. Finalement, nous avons regardé s’ils répondaient aux besoins et exigences du cahier des charges et si chacun des 3 outils (hébergement web, SGBD et éditeur) s’accordaient bien entre eux.\nAprès avoir analysé différentes solutions et choisi la meilleure du lot, nous avons pu faire un compte rendu de nos recherches et expliquer pourquoi nous recommandons une certaine combinaison de logiciels. Pour cela nous avons présenté les avantages et défauts de chaque logiciel et pourquoi leurs concurrents correspondaient moins aux besoins.\nUne fois le compte-rendu créé, nous avons écrit un manuel en anglais expliquant étape par étape comment installer et mettre en place chaque logiciel. Ainsi les clients pouvaient savoir comment et pourquoi utiliser les outils recommandés.",
        "image2": "sources/projets/2/wamp.webp",
        "DescriptionIMG2": "WAMP : solution finale choisi",
        "paragraphe3": "Ce travail m’a permis de mobiliser des compétences distinctes et variées. En effet j’ai dû comparer des logiciels sur des caractéristiques assez général (les prix et la facilité d’installation) mais aussi sur des éléments plus techniques qui peuvent avoir de l’importance. Par exemple l’efficacité selon la taille du site web, la prise en charge de certaines fonctionnalités, la méthode de stockage du SGBD ou bien la comptabilité selon les langages de programmation utilisés. Le compte rendu et le manuel m’ont quant à eux fait travailler mes capacités  d’anglais et celles à résumer un projet.\nCe travail m’a aussi permis d’entretenir ma capacité à travailler en groupe et communiquer pour s’assurer que nos recherches et nos réflexions coïncidaient.\nBien que nous ayons fourni une combinaison correcte qui répond aux besoins du client, chaque outil possédait tellement de spécificités que choisir une seule solution est assez complexe. Nous n’avons donc sûrement pas fourni la meilleure combinaison mais simplement une suffisante.",
        "image3": "sources/projets/2/ide.webp",
        "DescriptionIMG3": "IDE choisi comme solution finale"
    },
    {
        "titre": "Étude d’un cahier des charges et création d'une base de données",
        "paragraphe1": "Ce travail fait suite au projet sur lequel nous avons dû rechercher les meilleurs outils web pour organiser une game jam. Nous avons alors trouvé un hébergeur web, un système de gestion de base de données (SGBD) et un éditeur de code. Mais pour que le site puisse être fonctionnelle, il est nécessaire de créer une base de données cohérente et sécurisée. C’est-ce que notre groupe de 5 a essayé de fournir.",
        "image1": "sources/projets/3/mcd.webp",
        "DescriptionIMG1": "Modèle Conceptuel des Données (MCD)",
        "paragraphe2": "Pour cela, nous avons tout d’abord analyser le cahier des charges pour comprendre plus précisément les besoins et contraintes. Ensuite, nous avons fait un brainstorming pour relever les mots qui pourraient correspondre à des tables et ceux qui correspondraient à des entités au sein de ces tables. Avec ces idées en tête, nous avons pu créer un modèle conceptuel de données (MCD) et commencer à imaginer les liens entre les tables pour vérifier la cohérence de notre MCD. Une fois cette étape terminée, nous avons pu imaginer le modèle logique de données (MLD). Ce modèle correspond plus ou moins à traduire notre MCD en une base de données concrète. Les anciens liens ont donc été soit supprimés car non nécessaires, soit laissés comme tel, soit transformés en une table intermédiaire si un lien clé primaire/étrangère était insuffisant. Une fois le MLD complet et cohérent, nous avons pu entamer la création de la base de données à l’aide de requêtes SQL pour gérer le type de données et les liens clé primaire/étrangère. Pour pouvoir tester notre base de données, nous avons intégré un jeu de données créé par ChatGPT et avons fait des tests à l’aide de requêtes SQL. Ces requêtes correspondent à des informations que les organisateurs de la game jam pourraient réclamer.\r\nFinalement, nous avons regroupé toutes nos axes de réflexion et l’évolution de notre projet au sein d’un compte rendu.",
        "image2": "sources/projets/3/mld.webp",
        "DescriptionIMG2": "Modèle Logique des Données (MLD)",
        "paragraphe3": "Ce projet m’a permis de découvrir plus en détail le logiciel PHPMyAdmin et d’exploiter mes compétences en SQL. Mais le SQL n’a pas été la partie la plus importante de ce travail. C’est en réalité la conception de la base de données. Réfléchir au MCD et au MLD demande une longue phase de réflexion intensif pour trouver la meilleure solution. De plus, effectuer ce travail en groupe nécessitait une bonne communication et capacité à se faire comprendre pour arriver à un résultat qui satisfait tout le monde.\r\nLa création d’une base de données a été l’un de mes travaux les plus dur à faire. La phase de réflexion sur le MCD et MLD est particulièrement complexe. Il faut être capable de prendre en compte de nombreuses informations et avoir la capacité d’imaginer la base de données à chaque étape du projet. Si une erreur est faite au début de la réflexion et qu’elle n’est pas tout de suite réglée c’est toute la base qui en sera impactée. Notre groupe a fourni une base de données répondant à plusieurs besoins, mais à cause de quelques erreurs faites sur le MCD nous avons été incapable de fournir certaines requêtes SQL pourtant nécessaires.",
        "image3": "sources/projets/3/",
        "DescriptionIMG3": "N/A"
    }
]